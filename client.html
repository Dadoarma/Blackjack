<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Blackjack</title>
    <style>
        :root {
            --bg-color: #2e7d32;
            --card-color: white;
            --card-back-color: #1565c0;
            --primary-color: #4caf50;
            --secondary-color: #ffeb3b;
            --danger-color: #d32f2f;
            --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--card-color);
            text-align: center;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 { font-size: 2.5em; margin-bottom: 20px; color: var(--secondary-color); text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .hidden { display: none; }
        .lobby-box, #game { background: #1b5e20; padding: 30px; border-radius: 12px; max-width: 90%; width: 450px; margin: 20px auto; box-shadow: var(--shadow-light); }
        .lobby-box input { padding: 10px; font-size: 16px; margin: 10px 0; width: 80%; border-radius: 6px; border: 1px solid #ccc; box-sizing: border-box; text-transform: uppercase; }
        #table-code { background: var(--primary-color); padding: 10px; border-radius: 6px; margin: 15px 0; font-size: 1.1em; font-weight: bold; letter-spacing: 1px; }
        button { margin: 8px; padding: 12px 24px; font-size: 16px; border: none; border-radius: 25px; cursor: pointer; background: var(--primary-color); color: white; transition: background 0.3s, opacity 0.3s; font-weight: bold; box-shadow: 0 4px 0 #388e3c; }
        button:hover:not(:disabled) { background: #388e3c; box-shadow: 0 2px 0 #388e3c; transform: translateY(2px); }
        button:disabled { background: #666; cursor: not-allowed; box-shadow: none; opacity: 0.7; transform: translateY(0); }
        .leave { background: var(--danger-color); box-shadow: 0 4px 0 #9f2424; }
        .leave:hover:not(:disabled) { background: #9f2424; box-shadow: 0 2px 0 #9f2424; }
        .card { display: inline-block; margin: 6px; padding: 15px 18px; background: var(--card-color); color: black; border-radius: 8px; font-size: 24px; font-weight: bold; box-shadow: var(--shadow-light); min-width: 30px; transition: transform 0.4s ease-out; border: 1px solid #aaa; }
        .card.hidden { background: var(--card-back-color); color: var(--card-back-color); border: 1px solid var(--card-back-color); position: relative; }
        .card.hidden::before { content: '‚ô†'; color: white; font-size: 1.5em; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .cards { margin: 20px 0; min-height: 80px; }
        .value { font-size: 1.2em; color: var(--secondary-color); margin: 10px 0; font-weight: bold; }
    </style>
</head>
<body>
<h1>üé∞ Blackjack Live</h1>

<!-- LOBBY -->
<div id="lobby">
    <div class="lobby-box">
        <h2>Welcome!</h2>
        <button onclick="connect('CREATE')">Create Table</button>
        <hr>
        <input id="code" placeholder="Enter 6-char code" maxlength="6">
        <button onclick="connect('JOIN ' + document.getElementById('code').value.toUpperCase())">Join Table</button>
    </div>
</div>

<!-- GAME -->
<div id="game" class="hidden">
    <div id="table-code"></div>
    <div id="waiting" class="value hidden">‚è≥ Sei in attesa, parteciperai al prossimo round</div>

    <h3>Dealer</h3>
    <div id="dval" class="value"></div>
    <div id="dcards" class="cards"></div>

    <h3>Player</h3>
    <div id="pval" class="value"></div>
    <div id="pcards" class="cards"></div>

    <div id="status" class="value"></div>

    <div class="actions">
        <button id="hit" onclick="send('HIT')" disabled>HIT</button>
        <button id="stand" onclick="send('STAND')" disabled>STAND</button>
        <button id="again" onclick="send('YES')" disabled>PLAY AGAIN</button>
    </div>

    <button class="leave" onclick="leave()">LEAVE</button>
</div>

<script>
/*
  Macro-sezioni:
   - Variabili e riferimenti UI
   - WebSocket: connessione e gestione messaggi
   - Funzioni di invio e controllo UI
   - Gestione carte e utilit√† (add, reveal, valori)
   - Funzioni ausiliarie
*/

// -------------------------
// Variabili e riferimenti UI (macro)
// -------------------------
// micro: selezione elementi DOM e stato locale
const [lobby, game, pcards, dcards, pval, dval, hit, stand, again, statusEl, waiting] =
  ['lobby', 'game', 'pcards', 'dcards', 'pval', 'dval', 'hit', 'stand', 'again', 'status', 'waiting'].map(id => document.getElementById(id));

let ws = null;          // WebSocket
let play = false;       // flag turno giocatore locale
let pc = [], dc = [];   // memorie client: player cards (pc) e dealer cards (dc)

// -------------------------
// WebSocket: connessione e gestione messaggi (macro)
// -------------------------
function connect(msg) {
    // micro: creer√† ws, invier√† CREATE/JOIN al server e gestir√† i messaggi in arrivo
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.host;
    ws = new WebSocket(`${protocol}//${host}`);

    ws.onopen = () => {
        console.log("WS open, sending:", msg);
        ws.send(msg);
    };

    ws.onmessage = async e => {
        // micro: parsing semplice (COMANDO <payload>)
        const raw = e.data;
        const partsSplit = raw.split(' ');
        const cmd = partsSplit[0] || raw;
        const payload = raw.includes(' ') ? raw.slice(cmd.length + 1) : "";

        console.log("WS recv:", { cmd, payload });

        // -------------------------
        // Macro: gestione comandi server
        // -------------------------
        if (cmd.startsWith("TABLE_")) {
            // macro: risposta su creazione/join tavolo
            if (cmd === "TABLE_CREATED" || cmd === "TABLE_JOINED") {
                lobby.classList.add("hidden");
                game.classList.remove("hidden");
                document.getElementById("table-code").textContent = "Code: " + (payload || "");
            } else if (cmd === "TABLE_NOT_FOUND") alert("Table not found!");
            else if (cmd === "TABLE_FULL") alert("Table full!");
        }
        else if (cmd === "PLAY_AGAIN_LOCK") {
            // macro: sei entrato mentre la partita √® in corso -> waiting
            waiting.classList.remove("hidden");
            btns(false, false, false);
        }
        else if (cmd === "PLAY_AGAIN?") {
            // macro: server chiede se vuoi rigiocare
            waiting.classList.add("hidden");
            again.disabled = false;
            hit.disabled = true;
            stand.disabled = true;
            play = false;
        }
        else if (cmd === "CARDS") {
            // macro: aggiornamento carte del player (payload comma-separated)
            const cards = payload ? payload.split(",").map(s => s.trim()).filter(Boolean) : [];
            // micro: animazione aggiunta solo delle nuove carte
            for (let c of cards.slice(pc.length)) { add(pcards, c); await wait(400); }
            pc = cards;
            update(pval, pc);
        }
        else if (cmd === "DEALER_RESET") {
            // macro: reset UI e stato (nuovo round)
            dcards.innerHTML = "";
            dval.textContent = "";
            pcards.innerHTML = "";
            pval.textContent = "";
            statusEl.textContent = "";
            dc = pc = [];
            btns(false, false, false);
            waiting.classList.add("hidden");
        }
        else if (cmd === "DEALER_INIT") {
            // macro: server invia le due carte iniziali del dealer (seconda coperta)
            // micro: payload expected "C1 C2"
            const parts = payload ? payload.split(" ").map(s => s.trim()).filter(Boolean) : [];
            dcards.innerHTML = ""; dc = [];
            if (parts[0]) { add(dcards, parts[0]); dc.push(parts[0]); }
            if (parts[1]) { add(dcards, parts[1], true); dc.push(parts[1]); } // seconda coperta
            const visibleValue = parts[0] ? val(parts[0]) : 0;
            dval.textContent = "Showing: " + visibleValue;
        }
        else if (cmd === "YOUR_TURN") {
            // macro: √® il tuo turno
            play = true;
            waiting.classList.add("hidden");
            btns(true, true, false);
        }
        else if (cmd === "DEALER_REVEAL") {
            // macro: rivelazione carta coperta del dealer
            // micro: payload opzionale con carte finali
            if (payload) {
                const final = payload.split(",").map(s => s.trim()).filter(Boolean);
                dcards.innerHTML = ""; dc = [];
                for (const card of final) { add(dcards, card); dc.push(card); }
                update(dval, dc);
            } else {
                revealHiddenDealerCard();
                update(dval, dc);
            }
            await wait(500);
        }
        else if (cmd === "DEALER_CARD") {
            // macro: il dealer pesca una carta aggiuntiva
            if (payload) {
                const card = payload.trim();
                dc.push(card);
                add(dcards, card);
                await wait(400);
                update(dval, dc);
            }
        }
        else if (cmd === "RESULT") {
            // macro: risultato finale per il player
            play = false;
            btns(false, false, false);
            const parts = payload ? payload.split(" ").map(s => s.trim()).filter(Boolean) : [];
            const result = parts[0] || "";
            const dealerIndex = parts.indexOf("DEALER");
            let dealerCardsStr = "";
            if (dealerIndex !== -1) dealerCardsStr = parts.slice(dealerIndex + 1).join(" ");

            statusEl.textContent = result ? ("Result: " + result) : "";

            if (dealerCardsStr) {
                // micro: normalizza lista carte dealer (virgole o spazi)
                const finalDealerCards = dealerCardsStr.includes(",")
                    ? dealerCardsStr.split(",").map(s => s.trim()).filter(Boolean)
                    : dealerCardsStr.split(" ").map(s => s.trim()).filter(Boolean);
                dcards.innerHTML = ""; dc = [];
                for (const card of finalDealerCards) { dc.push(card); add(dcards, card); }
                update(dval, dc);
            } else {
                // fallback: reveal eventuali carte nascoste
                revealHiddenDealerCard();
                update(dval, dc);
            }
        }
    };

    ws.onerror = (err) => {
        console.error("WebSocket error", err);
        alert("WebSocket error, controlla il server.");
    };

    ws.onclose = () => {
        console.log("WebSocket closed");
        // micro: reset UI al lobby
        game.classList.add("hidden");
        lobby.classList.remove("hidden");
        dcards.innerHTML = pcards.innerHTML = "";
        dval.textContent = pval.textContent = "";
        statusEl.textContent = "";
        waiting.classList.add("hidden");
        dc = pc = [];
    };
}

// -------------------------
// Invio comandi e controllo UI (macro)
// -------------------------
function send(m) {
    if (!ws || ws.readyState !== 1) { alert("Connessione non disponibile."); return; }
    if (m === "YES" && again.disabled) return;
    if (m === "HIT" && hit.disabled) return;
    if (m === "STAND" && stand.disabled) return;
    ws.send(m);
    if (m === "HIT" || m === "STAND") {
        // micro: disabilita bottoni dopo HIT/STAND per evitare doppi click
        play = false;
        btns(false, false, false);
    } else if (m === "YES") {
        again.disabled = true;
    }
}

function leave() {
    if (ws) ws.close();
    game.classList.add("hidden");
    lobby.classList.remove("hidden");
    dcards.innerHTML = pcards.innerHTML = "";
    dval.textContent = pval.textContent = "";
    statusEl.textContent = "";
    waiting.classList.add("hidden");
    dc = pc = [];
}

// micro: utility per abilitare/disabilitare bottoni
function btns(h, s, a) {
    hit.disabled = !h;
    stand.disabled = !s;
    again.disabled = !a;
}

// -------------------------
// Gestione carte e visual (macro)
// -------------------------

/* add
   - Aggiunge un elemento DOM 'card' in una lista (pcards o dcards)
   - Se hid==true la carta √® inizialmente "coperta" (class hidden)
   - Memorizza il valore reale in dataset.card per poterlo rivelare correttamente
*/
function add(el, txt, hid) {
    const d = document.createElement("div");
    d.className = "card" + (hid ? " hidden" : "");
    d.dataset.card = txt;   // micro: memorizzo il valore reale
    d.textContent = txt;    // impostato anche se hidden (verr√† reso visibile alla reveal)
    el.appendChild(d);
}

/* revealHiddenDealerCard
   - Cerca le carte con classe 'hidden' nell'area dealer e le rivela
   - Assicura che il testo diventi leggibile rimuovendo la classe prima di impostare il testo
*/
function revealHiddenDealerCard() {
    for (let i = 0; i < dcards.children.length; i++) {
        const child = dcards.children[i];
        if (child.classList.contains("hidden")) {
            child.classList.remove("hidden");
            const real = child.dataset.card || (dc[i] || child.textContent);
            child.textContent = real;
            if (!dc[i]) dc[i] = real; // sincronizza array dc
        }
    }
}

// -------------------------
// Logica valori carte (macro)
// -------------------------

// micro: val prende es. "J‚ô†" e restituisce valore numerico usato per il showing
function val(c) {
    if (!c) return 0;
    const v = c.slice(0, -1);
    if (v === "A") return 11;
    if (["J","Q","K"].includes(v)) return 10;
    const n = +v;
    return Number.isNaN(n) ? 0 : n;
}

// sum / update: calcolo valore mano (A flessibile)
function sum(cards) {
    let s = 0, a = 0;
    for (let c of cards) {
        if (!c) continue;
        const v = c.slice(0, -1);
        if (v === "A") { s += 11; a++; }
        else s += ["J","Q","K"].includes(v) ? 10 : +v;
    }
    while (s > 21 && a > 0) { s -= 10; a--; }
    return s;
}
function update(el, cards) {
    const s = sum(cards);
    el.textContent = "Value: " + s + (s > 21 ? " - BUST!" : s === 21 ? " - BLACKJACK!" : "");
}

// -------------------------
// Funzioni ausiliarie
// -------------------------
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
</script>
</body>
</html>
